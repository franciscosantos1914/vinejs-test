import validator from 'validator';
import { resolve4, resolve6 } from 'node:dns/promises';
const BOOLEAN_POSITIVES = ['1', 1, 'true', true, 'on'];
const BOOLEAN_NEGATIVES = ['0', 0, 'false', false];
export const helpers = {
    exists(value) {
        return value !== null && value !== undefined;
    },
    isMissing(value) {
        return !this.exists(value);
    },
    isTrue(value) {
        return BOOLEAN_POSITIVES.includes(value);
    },
    isFalse(value) {
        return BOOLEAN_NEGATIVES.includes(value);
    },
    isString(value) {
        return typeof value === 'string';
    },
    isObject(value) {
        return !!(value && typeof value === 'object' && !Array.isArray(value));
    },
    hasKeys(value, keys) {
        for (let key of keys) {
            if (key in value === false) {
                return false;
            }
        }
        return true;
    },
    isArray(value) {
        return Array.isArray(value);
    },
    isNumeric(value) {
        return !Number.isNaN(Number(value));
    },
    asNumber(value) {
        return value === null ? Number.NaN : Number(value);
    },
    asBoolean(value) {
        if (this.isTrue(value)) {
            return true;
        }
        if (this.isFalse(value)) {
            return false;
        }
        return null;
    },
    isEmail: validator.default.isEmail,
    isURL: validator.default.isURL,
    isAlpha: validator.default.isAlpha,
    isAlphaNumeric: validator.default.isAlphanumeric,
    isIP: validator.default.isIP,
    isUUID: validator.default.isUUID,
    isAscii: validator.default.isAscii,
    isCreditCard: validator.default.isCreditCard,
    isIBAN: validator.default.isIBAN,
    isJWT: validator.default.isJWT,
    isLatLong: validator.default.isLatLong,
    isMobilePhone: validator.default.isMobilePhone,
    isPassportNumber: validator.default.isPassportNumber,
    isPostalCode: validator.default.isPostalCode,
    isSlug: validator.default.isSlug,
    isDecimal: validator.default.isDecimal,
    mobileLocales: validator.default.isMobilePhoneLocales,
    postalCountryCodes: validator.default.isPostalCodeLocales,
    passportCountryCodes: [
        'AM',
        'AR',
        'AT',
        'AU',
        'AZ',
        'BE',
        'BG',
        'BR',
        'BY',
        'CA',
        'CH',
        'CY',
        'CZ',
        'DE',
        'DK',
        'DZ',
        'ES',
        'FI',
        'FR',
        'GB',
        'GR',
        'HR',
        'HU',
        'IE',
        'IN',
        'ID',
        'IR',
        'IS',
        'IT',
        'JM',
        'JP',
        'KR',
        'KZ',
        'LI',
        'LT',
        'LU',
        'LV',
        'LY',
        'MT',
        'MZ',
        'MY',
        'MX',
        'NL',
        'NZ',
        'PH',
        'PK',
        'PL',
        'PT',
        'RO',
        'RU',
        'SE',
        'SL',
        'SK',
        'TH',
        'TR',
        'UA',
        'US',
    ],
    isHexColor: (value) => {
        if (!value.startsWith('#')) {
            return false;
        }
        return validator.default.isHexColor(value);
    },
    isActiveURL: async (url) => {
        try {
            const { hostname } = new URL(url);
            const v6Addresses = await resolve6(hostname);
            if (v6Addresses.length) {
                return true;
            }
            else {
                const v4Addresses = await resolve4(hostname);
                return v4Addresses.length > 0;
            }
        }
        catch {
            return false;
        }
    },
    isDistinct: (dataSet, fields) => {
        const uniqueItems = new Set();
        if (!fields) {
            for (let item of dataSet) {
                if (helpers.exists(item)) {
                    if (uniqueItems.has(item)) {
                        return false;
                    }
                    else {
                        uniqueItems.add(item);
                    }
                }
            }
            return true;
        }
        const fieldsList = Array.isArray(fields) ? fields : [fields];
        for (let item of dataSet) {
            if (helpers.isObject(item) && helpers.hasKeys(item, fieldsList)) {
                const element = fieldsList.map((field) => item[field]).join('_');
                if (uniqueItems.has(element)) {
                    return false;
                }
                else {
                    uniqueItems.add(element);
                }
            }
        }
        return true;
    },
};
