import camelcase from 'camelcase';
import { BaseType } from '../base/main.js';
import { PARSE, UNIQUE_NAME, IS_OF_TYPE } from '../../symbols.js';
import { compactRule, notEmptyRule, distinctRule, minLengthRule, maxLengthRule, fixedLengthRule, } from './rules.js';
export class VineArray extends BaseType {
    static rules = {
        compact: compactRule,
        notEmpty: notEmptyRule,
        distinct: distinctRule,
        minLength: minLengthRule,
        maxLength: maxLengthRule,
        fixedLength: fixedLengthRule,
    };
    #schema;
    [UNIQUE_NAME] = 'vine.array';
    [IS_OF_TYPE] = (value) => {
        return Array.isArray(value);
    };
    constructor(schema, options, validations) {
        super(options, validations);
        this.#schema = schema;
    }
    minLength(expectedLength) {
        return this.use(minLengthRule({ min: expectedLength }));
    }
    maxLength(expectedLength) {
        return this.use(maxLengthRule({ max: expectedLength }));
    }
    fixedLength(expectedLength) {
        return this.use(fixedLengthRule({ size: expectedLength }));
    }
    notEmpty() {
        return this.use(notEmptyRule());
    }
    distinct(fields) {
        return this.use(distinctRule({ fields }));
    }
    compact() {
        return this.use(compactRule());
    }
    clone() {
        return new VineArray(this.#schema.clone(), this.cloneOptions(), this.cloneValidations());
    }
    [PARSE](propertyName, refs, options) {
        return {
            type: 'array',
            fieldName: propertyName,
            propertyName: options.toCamelCase ? camelcase(propertyName) : propertyName,
            bail: this.options.bail,
            allowNull: this.options.allowNull,
            isOptional: this.options.isOptional,
            each: this.#schema[PARSE]('*', refs, options),
            parseFnId: this.options.parse ? refs.trackParser(this.options.parse) : undefined,
            validations: this.compileValidations(refs),
        };
    }
}
