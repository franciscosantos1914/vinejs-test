import { OTYPE, COTYPE, PARSE, VALIDATION } from '../../symbols.js';
export class BaseModifiersType {
    optional() {
        return new OptionalModifier(this);
    }
    nullable() {
        return new NullableModifier(this);
    }
}
class NullableModifier extends BaseModifiersType {
    #parent;
    constructor(parent) {
        super();
        this.#parent = parent;
    }
    clone() {
        return new NullableModifier(this.#parent.clone());
    }
    [PARSE](propertyName, refs, options) {
        const output = this.#parent[PARSE](propertyName, refs, options);
        if (output.type !== 'union') {
            output.allowNull = true;
        }
        return output;
    }
}
class OptionalModifier extends BaseModifiersType {
    #parent;
    constructor(parent) {
        super();
        this.#parent = parent;
    }
    clone() {
        return new OptionalModifier(this.#parent.clone());
    }
    [PARSE](propertyName, refs, options) {
        const output = this.#parent[PARSE](propertyName, refs, options);
        if (output.type !== 'union') {
            output.isOptional = true;
        }
        return output;
    }
}
export class BaseType extends BaseModifiersType {
    options;
    validations;
    constructor(options, validations) {
        super();
        this.options = options || {
            bail: true,
            allowNull: false,
            isOptional: false,
        };
        this.validations = validations || [];
    }
    cloneValidations() {
        return this.validations.map((validation) => {
            return {
                options: validation.options,
                rule: validation.rule,
            };
        });
    }
    cloneOptions() {
        return { ...this.options };
    }
    compileValidations(refs) {
        return this.validations.map((validation) => {
            return {
                ruleFnId: refs.track({
                    validator: validation.rule.validator,
                    options: validation.options,
                }),
                implicit: validation.rule.implicit,
                isAsync: validation.rule.isAsync,
            };
        });
    }
    parse(callback) {
        this.options.parse = callback;
        return this;
    }
    use(validation) {
        this.validations.push(VALIDATION in validation ? validation[VALIDATION]() : validation);
        return this;
    }
    bail(state) {
        this.options.bail = state;
        return this;
    }
}
