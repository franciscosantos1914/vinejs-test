import camelcase from 'camelcase';
import { OTYPE, COTYPE, PARSE, VALIDATION } from '../../symbols.js';
class BaseModifiersType {
    optional() {
        return new OptionalModifier(this);
    }
    nullable() {
        return new NullableModifier(this);
    }
    transform(transformer) {
        return new TransformModifier(transformer, this);
    }
}
class NullableModifier extends BaseModifiersType {
    #parent;
    constructor(parent) {
        super();
        this.#parent = parent;
    }
    clone() {
        return new NullableModifier(this.#parent.clone());
    }
    [PARSE](propertyName, refs, options) {
        const output = this.#parent[PARSE](propertyName, refs, options);
        output.allowNull = true;
        return output;
    }
}
class OptionalModifier extends BaseModifiersType {
    #parent;
    constructor(parent) {
        super();
        this.#parent = parent;
    }
    clone() {
        return new OptionalModifier(this.#parent.clone());
    }
    [PARSE](propertyName, refs, options) {
        const output = this.#parent[PARSE](propertyName, refs, options);
        output.isOptional = true;
        return output;
    }
}
class TransformModifier extends BaseModifiersType {
    #parent;
    #transform;
    constructor(transform, parent) {
        super();
        this.#transform = transform;
        this.#parent = parent;
    }
    clone() {
        return new TransformModifier(this.#transform, this.#parent.clone());
    }
    [PARSE](propertyName, refs, options) {
        const output = this.#parent[PARSE](propertyName, refs, options);
        output.transformFnId = refs.trackTransformer(this.#transform);
        return output;
    }
}
export class BaseLiteralType extends BaseModifiersType {
    options;
    validations;
    constructor(options, validations) {
        super();
        this.options = {
            bail: true,
            allowNull: false,
            isOptional: false,
            ...options,
        };
        this.validations = validations || [];
    }
    cloneValidations() {
        return this.validations.map((validation) => {
            return {
                options: validation.options,
                rule: validation.rule,
            };
        });
    }
    cloneOptions() {
        return { ...this.options };
    }
    compileValidations(refs) {
        return this.validations.map((validation) => {
            return {
                ruleFnId: refs.track({
                    validator: validation.rule.validator,
                    options: validation.options,
                }),
                implicit: validation.rule.implicit,
                isAsync: validation.rule.isAsync,
            };
        });
    }
    parse(callback) {
        this.options.parse = callback;
        return this;
    }
    use(validation) {
        this.validations.push(VALIDATION in validation ? validation[VALIDATION]() : validation);
        return this;
    }
    bail(state) {
        this.options.bail = state;
        return this;
    }
    [PARSE](propertyName, refs, options) {
        return {
            type: 'literal',
            fieldName: propertyName,
            propertyName: options.toCamelCase ? camelcase(propertyName) : propertyName,
            bail: this.options.bail,
            allowNull: this.options.allowNull,
            isOptional: this.options.isOptional,
            parseFnId: this.options.parse ? refs.trackParser(this.options.parse) : undefined,
            validations: this.compileValidations(refs),
        };
    }
}
