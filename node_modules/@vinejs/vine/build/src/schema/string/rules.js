import validator from 'validator';
import { helpers } from '../../vine/helpers.js';
import { messages } from '../../defaults.js';
import { createRule } from '../../vine/create_rule.js';
import camelcase from 'camelcase';
import normalizeUrl from 'normalize-url';
export const stringRule = createRule((value, _, field) => {
    if (typeof value !== 'string') {
        field.report(messages.string, 'string', field);
    }
});
export const emailRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    if (!helpers.isEmail(value, options)) {
        field.report(messages.email, 'email', field);
    }
});
export const mobileRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    const normalizedOptions = options && typeof options === 'function' ? options(field) : options;
    const locales = normalizedOptions?.locale || 'any';
    if (!helpers.isMobilePhone(value, locales, normalizedOptions)) {
        field.report(messages.mobile, 'mobile', field);
    }
});
export const ipAddressRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    if (!helpers.isIP(value, options?.version)) {
        field.report(messages.ipAddress, 'ipAddress', field);
    }
});
export const regexRule = createRule((value, expression, field) => {
    if (!field.isValid) {
        return;
    }
    if (!expression.test(value)) {
        field.report(messages.regex, 'regex', field);
    }
});
export const hexCodeRule = createRule((value, _, field) => {
    if (!field.isValid) {
        return;
    }
    if (!helpers.isHexColor(value)) {
        field.report(messages.hexCode, 'hexCode', field);
    }
});
export const urlRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    if (!helpers.isURL(value, options)) {
        field.report(messages.url, 'url', field);
    }
});
export const activeUrlRule = createRule(async (value, _, field) => {
    if (!field.isValid) {
        return;
    }
    if (!(await helpers.isActiveURL(value))) {
        field.report(messages.activeUrl, 'activeUrl', field);
    }
});
export const alphaRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    let characterSet = 'a-zA-Z';
    if (options) {
        if (options.allowSpaces) {
            characterSet += '\\s';
        }
        if (options.allowDashes) {
            characterSet += '-';
        }
        if (options.allowUnderscores) {
            characterSet += '_';
        }
    }
    const expression = new RegExp(`^[${characterSet}]+$`);
    if (!expression.test(value)) {
        field.report(messages.alpha, 'alpha', field);
    }
});
export const alphaNumericRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    let characterSet = 'a-zA-Z0-9';
    if (options) {
        if (options.allowSpaces) {
            characterSet += '\\s';
        }
        if (options.allowDashes) {
            characterSet += '-';
        }
        if (options.allowUnderscores) {
            characterSet += '_';
        }
    }
    const expression = new RegExp(`^[${characterSet}]+$`);
    if (!expression.test(value)) {
        field.report(messages.alphaNumeric, 'alphaNumeric', field);
    }
});
export const minLengthRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    if (value.length < options.min) {
        field.report(messages.minLength, 'minLength', field, options);
    }
});
export const maxLengthRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    if (value.length > options.max) {
        field.report(messages.maxLength, 'maxLength', field, options);
    }
});
export const fixedLengthRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    if (value.length !== options.size) {
        field.report(messages.fixedLength, 'fixedLength', field, options);
    }
});
export const endsWithRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    if (!value.endsWith(options.substring)) {
        field.report(messages.endsWith, 'endsWith', field, options);
    }
});
export const startsWithRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    if (!value.startsWith(options.substring)) {
        field.report(messages.startsWith, 'startsWith', field, options);
    }
});
export const sameAsRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    const input = field.parent[options.otherField];
    if (input !== value) {
        field.report(messages.sameAs, 'sameAs', field, options);
        return;
    }
});
export const notSameAsRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    const input = field.parent[options.otherField];
    if (input === value) {
        field.report(messages.notSameAs, 'notSameAs', field, options);
        return;
    }
});
export const confirmedRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    const otherField = options?.confirmationField || `${field.name}_confirmation`;
    const input = field.parent[otherField];
    if (input !== value) {
        field.report(messages.confirmed, 'confirmed', field, { otherField });
        return;
    }
});
export const trimRule = createRule((value, _, field) => {
    if (!field.isValid) {
        return;
    }
    field.mutate(value.trim(), field);
});
export const normalizeEmailRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    field.mutate(validator.default.normalizeEmail(value, options), field);
});
export const toUpperCaseRule = createRule((value, locales, field) => {
    if (!field.isValid) {
        return;
    }
    field.mutate(value.toLocaleUpperCase(locales), field);
});
export const toLowerCaseRule = createRule((value, locales, field) => {
    if (!field.isValid) {
        return;
    }
    field.mutate(value.toLocaleLowerCase(locales), field);
});
export const toCamelCaseRule = createRule((value, _, field) => {
    if (!field.isValid) {
        return;
    }
    field.mutate(camelcase(value), field);
});
export const escapeRule = createRule((value, _, field) => {
    if (!field.isValid) {
        return;
    }
    field.mutate(validator.default.escape(value), field);
});
export const normalizeUrlRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    field.mutate(normalizeUrl(value, options), field);
});
export const inRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    const choices = typeof options.choices === 'function' ? options.choices(field) : options.choices;
    if (!choices.includes(value)) {
        field.report(messages.in, 'in', field, options);
        return;
    }
});
export const notInRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    const list = typeof options.list === 'function' ? options.list(field) : options.list;
    if (list.includes(value)) {
        field.report(messages.notIn, 'notIn', field, options);
        return;
    }
});
export const creditCardRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    const providers = options
        ? typeof options === 'function'
            ? options(field)?.provider || []
            : options.provider
        : [];
    if (!providers.length) {
        if (!helpers.isCreditCard(value)) {
            field.report(messages.creditCard, 'creditCard', field, {
                providersList: 'credit',
            });
        }
    }
    else {
        const matchesAnyProvider = providers.find((provider) => helpers.isCreditCard(value, { provider }));
        if (!matchesAnyProvider) {
            field.report(messages.creditCard, 'creditCard', field, {
                providers: providers,
                providersList: providers.join('/'),
            });
        }
    }
});
export const passportRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    const countryCodes = typeof options === 'function' ? options(field).countryCode : options.countryCode;
    const matchesAnyCountryCode = countryCodes.find((countryCode) => helpers.isPassportNumber(value, countryCode));
    if (!matchesAnyCountryCode) {
        field.report(messages.passport, 'passport', field, { countryCodes });
    }
});
export const postalCodeRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    const countryCodes = options
        ? typeof options === 'function'
            ? options(field)?.countryCode || []
            : options.countryCode
        : [];
    if (!countryCodes.length) {
        if (!helpers.isPostalCode(value, 'any')) {
            field.report(messages.postalCode, 'postalCode', field);
        }
    }
    else {
        const matchesAnyCountryCode = countryCodes.find((countryCode) => helpers.isPostalCode(value, countryCode));
        if (!matchesAnyCountryCode) {
            field.report(messages.postalCode, 'postalCode', field, { countryCodes });
        }
    }
});
export const uuidRule = createRule((value, options, field) => {
    if (!field.isValid) {
        return;
    }
    if (!options || !options.version) {
        if (!helpers.isUUID(value)) {
            field.report(messages.uuid, 'uuid', field);
        }
    }
    else {
        const matchesAnyVersion = options.version.find((version) => helpers.isUUID(value, version));
        if (!matchesAnyVersion) {
            field.report(messages.uuid, 'uuid', field, options);
        }
    }
});
export const asciiRule = createRule((value, _, field) => {
    if (!field.isValid) {
        return;
    }
    if (!helpers.isAscii(value)) {
        field.report(messages.ascii, 'ascii', field);
    }
});
export const ibanRule = createRule((value, _, field) => {
    if (!field.isValid) {
        return;
    }
    if (!helpers.isIBAN(value)) {
        field.report(messages.iban, 'iban', field);
    }
});
export const jwtRule = createRule((value, _, field) => {
    if (!field.isValid) {
        return;
    }
    if (!helpers.isJWT(value)) {
        field.report(messages.jwt, 'jwt', field);
    }
});
export const coordinatesRule = createRule((value, _, field) => {
    if (!field.isValid) {
        return;
    }
    if (!helpers.isLatLong(value)) {
        field.report(messages.coordinates, 'coordinates', field);
    }
});
