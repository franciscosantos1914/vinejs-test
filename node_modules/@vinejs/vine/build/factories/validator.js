import { AssertionError, deepEqual } from 'node:assert';
import { FieldFactory } from './field.js';
import { SimpleErrorReporter } from '../src/reporters/simple_error_reporter.js';
class ValidationResult {
    #outputValue;
    #reporter;
    constructor(outputValue, reporter) {
        this.#outputValue = outputValue;
        this.#reporter = reporter;
    }
    #assertionError(options) {
        const assertion = new AssertionError(options);
        Object.defineProperty(assertion, 'showDiff', { value: true });
        return assertion;
    }
    getOutput() {
        return this.#outputValue;
    }
    getErrors() {
        return this.#reporter.errors;
    }
    assertSucceeded() {
        if (this.#reporter.hasErrors) {
            const errorsCount = this.#reporter.errors.length;
            throw this.#assertionError({
                message: `Expected validation to pass. Instead failed with "${errorsCount} error(s)"`,
                operator: 'strictEqual',
                stackStartFn: this.assertSucceeded,
            });
        }
    }
    assertOutput(expectedOutput) {
        deepEqual(this.#outputValue, expectedOutput);
    }
    assertFailed() {
        if (!this.#reporter.hasErrors) {
            throw this.#assertionError({
                message: `Expected validation to report one or more errors`,
                operator: 'strictEqual',
                stackStartFn: this.assertFailed,
            });
        }
    }
    assertErrorsCount(count) {
        const errorsCount = this.#reporter.errors.length;
        if (errorsCount !== count) {
            throw this.#assertionError({
                message: `Expected validation to report "${count}" errors. Received "${errorsCount}"`,
                expected: count,
                actual: errorsCount,
                operator: 'strictEqual',
                stackStartFn: this.assertErrorsCount,
                showDiff: true,
            });
        }
    }
    assertError(message) {
        const messages = this.#reporter.errors.map((e) => e.message);
        if (!messages.includes(message)) {
            throw this.#assertionError({
                message: `Expected validation errors to include "${message}" message`,
                expected: [message],
                actual: messages,
                operator: 'includes',
                stackStartFn: this.assertError,
                showDiff: true,
            });
        }
    }
}
export class ValidatorFactory {
    #field;
    #bail;
    constructor(field, bail) {
        this.#field = field;
        this.#bail = bail;
    }
    #getReporter() {
        return new SimpleErrorReporter();
    }
    withContext(field) {
        return new ValidatorFactory(field, this.#bail);
    }
    bail(state) {
        return new ValidatorFactory(this.#field, state);
    }
    execute(validation, value) {
        const errorReporter = this.#getReporter();
        const bail = this.#bail === false ? false : true;
        const field = {
            ...new FieldFactory().create('dummy', value, undefined, errorReporter),
            ...this.#field,
        };
        const validations = Array.isArray(validation) ? validation : [validation];
        for (let one of validations) {
            if (one.rule.isAsync) {
                throw new Error(`Cannot execute async rule "${one.rule.validator.name}". Use "validator.executeAsync" instead`);
            }
            if ((field.isDefined || one.rule.implicit) && (field.isValid || !bail)) {
                one.rule.validator(field.value, one.options, field);
            }
        }
        return new ValidationResult(field.value, errorReporter);
    }
    async executeAsync(validation, value) {
        const errorReporter = this.#getReporter();
        const bail = this.#bail === false ? false : true;
        const field = {
            ...new FieldFactory().create('dummy', value, undefined, errorReporter),
            ...this.#field,
        };
        const validations = Array.isArray(validation) ? validation : [validation];
        for (let one of validations) {
            if ((field.isDefined || one.rule.implicit) && (field.isValid || !bail)) {
                await one.rule.validator(field.value, one.options, field);
            }
        }
        return new ValidationResult(field.value, errorReporter);
    }
}
