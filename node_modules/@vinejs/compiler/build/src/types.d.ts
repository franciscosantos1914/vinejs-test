export type RefIdentifier = `ref://${number}`;
export type Refs = Record<RefIdentifier, ValidationRule | TransformFn<any, any> | ParseFn | ConditionalFn<any>>;
export type RefsStore = {
    toJSON(): Refs;
    track(value: Refs[keyof Refs]): RefIdentifier;
    trackValidation(validation: ValidationRule): RefIdentifier;
    trackParser(fn: ParseFn): RefIdentifier;
    trackTransformer(fn: TransformFn<any, any>): RefIdentifier;
    trackConditional(fn: ConditionalFn<any>): RefIdentifier;
};
export type FieldContext = {
    value: unknown;
    data: any;
    meta: Record<string, any>;
    mutate(newValue: any, field: FieldContext): void;
    report: ErrorReporterContract['report'];
    isValid: boolean;
    isDefined: boolean;
    wildCardPath: string;
    parent: any;
    name: string | number;
    isArrayMember: boolean;
};
export type ValidationRule = {
    validator(value: unknown, options: any, field: FieldContext): any;
    options?: any;
};
export type ParseFn = (value: unknown) => any;
export type TransformFn<Input, Output> = (value: Input, field: FieldContext) => Output;
export type ConditionalFn<Input> = (value: Input, field: FieldContext) => boolean;
export type ValidationNode = {
    ruleFnId: RefIdentifier;
    isAsync: boolean;
    implicit: boolean;
};
export type FieldNode = {
    bail: boolean;
    fieldName: string;
    propertyName: string;
    isOptional: boolean;
    allowNull: boolean;
    parseFnId?: RefIdentifier;
    validations: ValidationNode[];
};
export type LiteralNode = FieldNode & {
    type: 'literal';
    transformFnId?: RefIdentifier;
};
export type ObjectNode = FieldNode & {
    type: 'object';
    allowUnknownProperties: boolean;
    properties: CompilerNodes[];
    groups: ObjectGroupNode[];
};
export type ObjectGroupNode = {
    type: 'group';
    elseConditionalFnRefId?: RefIdentifier;
    conditions: {
        conditionalFnRefId: RefIdentifier;
        schema: {
            type: 'sub_object';
            properties: CompilerNodes[];
            groups: ObjectGroupNode[];
        };
    }[];
};
export type TupleNode = FieldNode & {
    type: 'tuple';
    allowUnknownProperties: boolean;
    properties: CompilerNodes[];
};
export type RecordNode = FieldNode & {
    type: 'record';
    each: CompilerNodes;
};
export type ArrayNode = FieldNode & {
    type: 'array';
    each: CompilerNodes;
};
export type UnionNode = {
    type: 'union';
    fieldName: string;
    propertyName: string;
    elseConditionalFnRefId?: RefIdentifier;
    conditions: {
        conditionalFnRefId: RefIdentifier;
        schema: CompilerNodes;
    }[];
};
export type RootNode = {
    type: 'root';
    schema: CompilerNodes;
};
export type CompilerNodes = LiteralNode | ObjectNode | ArrayNode | UnionNode | RecordNode | TupleNode;
export type CompilerParent = {
    type: 'array' | 'object' | 'tuple' | 'record' | 'root';
    wildCardPath: string;
    variableName: string;
    fieldPathExpression: string;
    outputExpression: string;
};
export type CompilerField = {
    parentValueExpression: string;
    fieldNameExpression: string;
    fieldPathExpression: string;
    variableName: string;
    wildCardPath: string;
    valueExpression: string;
    outputExpression: string;
    isArrayMember: boolean;
};
export interface ErrorReporterContract {
    hasErrors: boolean;
    createError(): Error;
    report(message: string, rule: string, field: FieldContext, args?: Record<string, any>): any;
}
export interface MessagesProviderContact {
    getMessage(defaultMessage: string, rule: string, field: FieldContext, args?: Record<string, any>): string;
}
export type CompilerOptions = {
    convertEmptyStringsToNull: boolean;
    messages?: Partial<{
        required: string;
        object: string;
        array: string;
    }>;
};
//# sourceMappingURL=types.d.ts.map