import { CompilerBuffer } from './buffer.js';
import { TupleNodeCompiler } from './nodes/tuple.js';
import { ArrayNodeCompiler } from './nodes/array.js';
import { UnionNodeCompiler } from './nodes/union.js';
import { RecordNodeCompiler } from './nodes/record.js';
import { ObjectNodeCompiler } from './nodes/object.js';
import { createRootField } from './fields/root_field.js';
import { LiteralNodeCompiler } from './nodes/literal.js';
import { createArrayField } from './fields/array_field.js';
import { createTupleField } from './fields/tuple_field.js';
import { reportErrors } from '../scripts/report_errors.js';
import { createObjectField } from './fields/object_field.js';
import { createRecordField } from './fields/record_field.js';
import { defineInlineFunctions } from '../scripts/define_inline_functions.js';
import { defineInlineErrorMessages } from '../scripts/define_error_messages.js';
const AsyncFunction = Object.getPrototypeOf(async function () { }).constructor;
export class Compiler {
    variablesCounter = 0;
    #rootNode;
    #options;
    #buffer = new CompilerBuffer();
    constructor(rootNode, options) {
        this.#rootNode = rootNode;
        this.#options = options || { convertEmptyStringsToNull: false };
    }
    #initiateJSOutput() {
        this.#buffer.writeStatement(defineInlineErrorMessages({
            required: 'value is required',
            object: 'value is not a valid object',
            array: 'value is not a valid array',
            ...this.#options.messages,
        }));
        this.#buffer.writeStatement(defineInlineFunctions(this.#options));
        this.#buffer.writeStatement('let out;');
    }
    #finishJSOutput() {
        this.#buffer.writeStatement(reportErrors());
        this.#buffer.writeStatement('return out;');
    }
    #compileNodes() {
        this.compileNode(this.#rootNode.schema, this.#buffer, {
            type: 'root',
            variableName: 'root',
            outputExpression: 'out',
            fieldPathExpression: 'out',
            wildCardPath: '',
        });
    }
    #toAsyncFunction() {
        return new AsyncFunction('root', 'meta', 'refs', 'messagesProvider', 'errorReporter', this.#buffer.toString());
    }
    createFieldFor(node, parent) {
        switch (parent.type) {
            case 'array':
                return createArrayField(parent);
            case 'root':
                return createRootField(parent);
            case 'object':
                return createObjectField(node, this.variablesCounter, parent);
            case 'tuple':
                return createTupleField(node, parent);
            case 'record':
                return createRecordField(parent);
        }
    }
    compileNode(node, buffer, parent, parentField) {
        switch (node.type) {
            case 'literal':
                return new LiteralNodeCompiler(node, buffer, this, parent, parentField).compile();
            case 'array':
                return new ArrayNodeCompiler(node, buffer, this, parent, parentField).compile();
            case 'record':
                return new RecordNodeCompiler(node, buffer, this, parent, parentField).compile();
            case 'object':
                return new ObjectNodeCompiler(node, buffer, this, parent, parentField).compile();
            case 'tuple':
                return new TupleNodeCompiler(node, buffer, this, parent, parentField).compile();
            case 'union':
                return new UnionNodeCompiler(node, buffer, this, parent, parentField).compile();
        }
    }
    compile() {
        this.#initiateJSOutput();
        this.#compileNodes();
        this.#finishJSOutput();
        const outputFunction = this.#toAsyncFunction();
        this.variablesCounter = 0;
        this.#buffer.flush();
        return outputFunction;
    }
}
